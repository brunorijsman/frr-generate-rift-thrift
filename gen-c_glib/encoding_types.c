/**
 * Autogenerated by Thrift Compiler (1.0.0-dev)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#include <math.h>

#include "encoding_types.h"
#include <thrift/c_glib/thrift.h>

/* return the name of the constant */
const char *
toString_HierarchyIndications(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case HIERARCHY_INDICATIONS_leaf_only:return "HIERARCHY_INDICATIONS_leaf_only";
  case HIERARCHY_INDICATIONS_leaf_only_and_leaf_2_leaf_procedures:return "HIERARCHY_INDICATIONS_leaf_only_and_leaf_2_leaf_procedures";
  case HIERARCHY_INDICATIONS_top_of_fabric:return "HIERARCHY_INDICATIONS_top_of_fabric";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_TieDirectionType(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case TIE_DIRECTION_TYPE_Illegal:return "TIE_DIRECTION_TYPE_Illegal";
  case TIE_DIRECTION_TYPE_South:return "TIE_DIRECTION_TYPE_South";
  case TIE_DIRECTION_TYPE_North:return "TIE_DIRECTION_TYPE_North";
  case TIE_DIRECTION_TYPE_DirectionMaxValue:return "TIE_DIRECTION_TYPE_DirectionMaxValue";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_AddressFamilyType(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case ADDRESS_FAMILY_TYPE_Illegal:return "ADDRESS_FAMILY_TYPE_Illegal";
  case ADDRESS_FAMILY_TYPE_AddressFamilyMinValue:return "ADDRESS_FAMILY_TYPE_AddressFamilyMinValue";
  case ADDRESS_FAMILY_TYPE_IPv4:return "ADDRESS_FAMILY_TYPE_IPv4";
  case ADDRESS_FAMILY_TYPE_IPv6:return "ADDRESS_FAMILY_TYPE_IPv6";
  case ADDRESS_FAMILY_TYPE_AddressFamilyMaxValue:return "ADDRESS_FAMILY_TYPE_AddressFamilyMaxValue";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_TIETypeType(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case T_I_E_TYPE_TYPE_Illegal:return "T_I_E_TYPE_TYPE_Illegal";
  case T_I_E_TYPE_TYPE_TIETypeMinValue:return "T_I_E_TYPE_TYPE_TIETypeMinValue";
  case T_I_E_TYPE_TYPE_NodeTIEType:return "T_I_E_TYPE_TYPE_NodeTIEType";
  case T_I_E_TYPE_TYPE_PrefixTIEType:return "T_I_E_TYPE_TYPE_PrefixTIEType";
  case T_I_E_TYPE_TYPE_PositiveDisaggregationPrefixTIEType:return "T_I_E_TYPE_TYPE_PositiveDisaggregationPrefixTIEType";
  case T_I_E_TYPE_TYPE_NegativeDisaggregationPrefixTIEType:return "T_I_E_TYPE_TYPE_NegativeDisaggregationPrefixTIEType";
  case T_I_E_TYPE_TYPE_PGPrefixTIEType:return "T_I_E_TYPE_TYPE_PGPrefixTIEType";
  case T_I_E_TYPE_TYPE_KeyValueTIEType:return "T_I_E_TYPE_TYPE_KeyValueTIEType";
  case T_I_E_TYPE_TYPE_ExternalPrefixTIEType:return "T_I_E_TYPE_TYPE_ExternalPrefixTIEType";
  case T_I_E_TYPE_TYPE_TIETypeMaxValue:return "T_I_E_TYPE_TYPE_TIETypeMaxValue";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_RouteType(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case ROUTE_TYPE_Illegal:return "ROUTE_TYPE_Illegal";
  case ROUTE_TYPE_RouteTypeMinValue:return "ROUTE_TYPE_RouteTypeMinValue";
  case ROUTE_TYPE_Discard:return "ROUTE_TYPE_Discard";
  case ROUTE_TYPE_LocalPrefix:return "ROUTE_TYPE_LocalPrefix";
  case ROUTE_TYPE_SouthPGPPrefix:return "ROUTE_TYPE_SouthPGPPrefix";
  case ROUTE_TYPE_NorthPGPPrefix:return "ROUTE_TYPE_NorthPGPPrefix";
  case ROUTE_TYPE_NorthPrefix:return "ROUTE_TYPE_NorthPrefix";
  case ROUTE_TYPE_NorthExternalPrefix:return "ROUTE_TYPE_NorthExternalPrefix";
  case ROUTE_TYPE_SouthPrefix:return "ROUTE_TYPE_SouthPrefix";
  case ROUTE_TYPE_SouthExternalPrefix:return "ROUTE_TYPE_SouthExternalPrefix";
  case ROUTE_TYPE_NegativeSouthPrefix:return "ROUTE_TYPE_NegativeSouthPrefix";
  case ROUTE_TYPE_RouteTypeMaxValue:return "ROUTE_TYPE_RouteTypeMaxValue";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

enum _IEEE802_1ASTimeStampTypeProperties
{
  PROP_I_E_E_E802_1_A_S_TIME_STAMP_TYPE_0,
  PROP_I_E_E_E802_1_A_S_TIME_STAMP_TYPE_A_S_SEC,
  PROP_I_E_E_E802_1_A_S_TIME_STAMP_TYPE_A_S_NSEC
};

/* reads a i_e_e_e802_1_a_s_time_stamp_type object */
static gint32
i_e_e_e802_1_a_s_time_stamp_type_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IEEE802_1ASTimeStampType * this_object = I_E_E_E802_1_A_S_TIME_STAMP_TYPE(object);
  gboolean isset_AS_sec = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->AS_sec, error)) < 0)
            return -1;
          xfer += ret;
          isset_AS_sec = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->AS_nsec, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_AS_nsec = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_AS_sec)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
i_e_e_e802_1_a_s_time_stamp_type_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IEEE802_1ASTimeStampType * this_object = I_E_E_E802_1_A_S_TIME_STAMP_TYPE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IEEE802_1ASTimeStampType", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "AS_sec", T_I64, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->AS_sec, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_AS_nsec == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "AS_nsec", T_I32, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->AS_nsec, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_e_e_e802_1_a_s_time_stamp_type_set_property (GObject *object,
                                               guint property_id,
                                               const GValue *value,
                                               GParamSpec *pspec)
{
  IEEE802_1ASTimeStampType *self = I_E_E_E802_1_A_S_TIME_STAMP_TYPE (object);

  switch (property_id)
  {
    case PROP_I_E_E_E802_1_A_S_TIME_STAMP_TYPE_A_S_SEC:
      self->AS_sec = g_value_get_int64 (value);
      break;

    case PROP_I_E_E_E802_1_A_S_TIME_STAMP_TYPE_A_S_NSEC:
      self->AS_nsec = g_value_get_int (value);
      self->__isset_AS_nsec = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_e_e_e802_1_a_s_time_stamp_type_get_property (GObject *object,
                                               guint property_id,
                                               GValue *value,
                                               GParamSpec *pspec)
{
  IEEE802_1ASTimeStampType *self = I_E_E_E802_1_A_S_TIME_STAMP_TYPE (object);

  switch (property_id)
  {
    case PROP_I_E_E_E802_1_A_S_TIME_STAMP_TYPE_A_S_SEC:
      g_value_set_int64 (value, self->AS_sec);
      break;

    case PROP_I_E_E_E802_1_A_S_TIME_STAMP_TYPE_A_S_NSEC:
      g_value_set_int (value, self->AS_nsec);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_e_e_e802_1_a_s_time_stamp_type_instance_init (IEEE802_1ASTimeStampType * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->AS_sec = 0;
  object->AS_nsec = 0;
  object->__isset_AS_nsec = FALSE;
}

static void 
i_e_e_e802_1_a_s_time_stamp_type_finalize (GObject *object)
{
  IEEE802_1ASTimeStampType *tobject = I_E_E_E802_1_A_S_TIME_STAMP_TYPE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
i_e_e_e802_1_a_s_time_stamp_type_class_init (IEEE802_1ASTimeStampTypeClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_e_e_e802_1_a_s_time_stamp_type_read;
  struct_class->write = i_e_e_e802_1_a_s_time_stamp_type_write;

  gobject_class->finalize = i_e_e_e802_1_a_s_time_stamp_type_finalize;
  gobject_class->get_property = i_e_e_e802_1_a_s_time_stamp_type_get_property;
  gobject_class->set_property = i_e_e_e802_1_a_s_time_stamp_type_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_E_E_E802_1_A_S_TIME_STAMP_TYPE_A_S_SEC,
     g_param_spec_int64 ("AS_sec",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_E_E_E802_1_A_S_TIME_STAMP_TYPE_A_S_NSEC,
     g_param_spec_int ("AS_nsec",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
i_e_e_e802_1_a_s_time_stamp_type_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IEEE802_1ASTimeStampTypeClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_e_e_e802_1_a_s_time_stamp_type_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IEEE802_1ASTimeStampType),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_e_e_e802_1_a_s_time_stamp_type_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IEEE802_1ASTimeStampTypeType",
                                   &type_info, 0);
  }

  return type;
}

enum _IPv4PrefixTypeProperties
{
  PROP_I_PV4_PREFIX_TYPE_0,
  PROP_I_PV4_PREFIX_TYPE_ADDRESS,
  PROP_I_PV4_PREFIX_TYPE_PREFIXLEN
};

/* reads a i_pv4_prefix_type object */
static gint32
i_pv4_prefix_type_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IPv4PrefixType * this_object = I_PV4_PREFIX_TYPE(object);
  gboolean isset_address = FALSE;
  gboolean isset_prefixlen = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->address, error)) < 0)
            return -1;
          xfer += ret;
          isset_address = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_BYTE)
        {
          if ((ret = thrift_protocol_read_byte (protocol, &this_object->prefixlen, error)) < 0)
            return -1;
          xfer += ret;
          isset_prefixlen = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_address)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_prefixlen)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
i_pv4_prefix_type_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IPv4PrefixType * this_object = I_PV4_PREFIX_TYPE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IPv4PrefixType", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "address", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->address, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "prefixlen", T_BYTE, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_byte (protocol, this_object->prefixlen, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_pv4_prefix_type_set_property (GObject *object,
                                guint property_id,
                                const GValue *value,
                                GParamSpec *pspec)
{
  IPv4PrefixType *self = I_PV4_PREFIX_TYPE (object);

  switch (property_id)
  {
    case PROP_I_PV4_PREFIX_TYPE_ADDRESS:
      self->address = g_value_get_int (value);
      break;

    case PROP_I_PV4_PREFIX_TYPE_PREFIXLEN:
      self->prefixlen = g_value_get_int (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_pv4_prefix_type_get_property (GObject *object,
                                guint property_id,
                                GValue *value,
                                GParamSpec *pspec)
{
  IPv4PrefixType *self = I_PV4_PREFIX_TYPE (object);

  switch (property_id)
  {
    case PROP_I_PV4_PREFIX_TYPE_ADDRESS:
      g_value_set_int (value, self->address);
      break;

    case PROP_I_PV4_PREFIX_TYPE_PREFIXLEN:
      g_value_set_int (value, self->prefixlen);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_pv4_prefix_type_instance_init (IPv4PrefixType * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->address = 0;
  object->prefixlen = 0;
}

static void 
i_pv4_prefix_type_finalize (GObject *object)
{
  IPv4PrefixType *tobject = I_PV4_PREFIX_TYPE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
i_pv4_prefix_type_class_init (IPv4PrefixTypeClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_pv4_prefix_type_read;
  struct_class->write = i_pv4_prefix_type_write;

  gobject_class->finalize = i_pv4_prefix_type_finalize;
  gobject_class->get_property = i_pv4_prefix_type_get_property;
  gobject_class->set_property = i_pv4_prefix_type_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_PV4_PREFIX_TYPE_ADDRESS,
     g_param_spec_int ("address",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_PV4_PREFIX_TYPE_PREFIXLEN,
     g_param_spec_int ("prefixlen",
                       NULL,
                       NULL,
                       G_MININT8,
                       G_MAXINT8,
                       0,
                       G_PARAM_READWRITE));
}

GType
i_pv4_prefix_type_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IPv4PrefixTypeClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_pv4_prefix_type_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IPv4PrefixType),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_pv4_prefix_type_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IPv4PrefixTypeType",
                                   &type_info, 0);
  }

  return type;
}

enum _IPv6PrefixTypeProperties
{
  PROP_I_PV6_PREFIX_TYPE_0,
  PROP_I_PV6_PREFIX_TYPE_ADDRESS,
  PROP_I_PV6_PREFIX_TYPE_PREFIXLEN
};

/* reads a i_pv6_prefix_type object */
static gint32
i_pv6_prefix_type_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IPv6PrefixType * this_object = I_PV6_PREFIX_TYPE(object);
  gboolean isset_address = FALSE;
  gboolean isset_prefixlen = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->address != NULL)
          {
            g_free(this_object->address);
            this_object->address = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->address = g_byte_array_new();
          g_byte_array_append (this_object->address, (guint8 *) data, (guint) len);
          g_free (data);
          isset_address = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_BYTE)
        {
          if ((ret = thrift_protocol_read_byte (protocol, &this_object->prefixlen, error)) < 0)
            return -1;
          xfer += ret;
          isset_prefixlen = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_address)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_prefixlen)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
i_pv6_prefix_type_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IPv6PrefixType * this_object = I_PV6_PREFIX_TYPE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IPv6PrefixType", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "address", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->address ? ((GByteArray *) this_object->address)->data : NULL, this_object->address ? ((GByteArray *) this_object->address)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "prefixlen", T_BYTE, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_byte (protocol, this_object->prefixlen, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_pv6_prefix_type_set_property (GObject *object,
                                guint property_id,
                                const GValue *value,
                                GParamSpec *pspec)
{
  IPv6PrefixType *self = I_PV6_PREFIX_TYPE (object);

  switch (property_id)
  {
    case PROP_I_PV6_PREFIX_TYPE_ADDRESS:
      if (self->address != NULL)
        g_byte_array_unref (self->address);
      self->address = g_value_dup_boxed (value);
      break;

    case PROP_I_PV6_PREFIX_TYPE_PREFIXLEN:
      self->prefixlen = g_value_get_int (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_pv6_prefix_type_get_property (GObject *object,
                                guint property_id,
                                GValue *value,
                                GParamSpec *pspec)
{
  IPv6PrefixType *self = I_PV6_PREFIX_TYPE (object);

  switch (property_id)
  {
    case PROP_I_PV6_PREFIX_TYPE_ADDRESS:
      g_value_set_boxed (value, self->address);
      break;

    case PROP_I_PV6_PREFIX_TYPE_PREFIXLEN:
      g_value_set_int (value, self->prefixlen);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_pv6_prefix_type_instance_init (IPv6PrefixType * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->address = NULL;
  object->prefixlen = 0;
}

static void 
i_pv6_prefix_type_finalize (GObject *object)
{
  IPv6PrefixType *tobject = I_PV6_PREFIX_TYPE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->address != NULL)
  {
    thrift_string_free(tobject->address);
    tobject->address = NULL;
  }
}

static void
i_pv6_prefix_type_class_init (IPv6PrefixTypeClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_pv6_prefix_type_read;
  struct_class->write = i_pv6_prefix_type_write;

  gobject_class->finalize = i_pv6_prefix_type_finalize;
  gobject_class->get_property = i_pv6_prefix_type_get_property;
  gobject_class->set_property = i_pv6_prefix_type_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_PV6_PREFIX_TYPE_ADDRESS,
     g_param_spec_boxed ("address",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_PV6_PREFIX_TYPE_PREFIXLEN,
     g_param_spec_int ("prefixlen",
                       NULL,
                       NULL,
                       G_MININT8,
                       G_MAXINT8,
                       0,
                       G_PARAM_READWRITE));
}

GType
i_pv6_prefix_type_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IPv6PrefixTypeClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_pv6_prefix_type_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IPv6PrefixType),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_pv6_prefix_type_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IPv6PrefixTypeType",
                                   &type_info, 0);
  }

  return type;
}

enum _IPAddressTypeProperties
{
  PROP_I_P_ADDRESS_TYPE_0,
  PROP_I_P_ADDRESS_TYPE_IPV4ADDRESS,
  PROP_I_P_ADDRESS_TYPE_IPV6ADDRESS
};

/* reads a i_p_address_type object */
static gint32
i_p_address_type_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IPAddressType * this_object = I_P_ADDRESS_TYPE(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->ipv4address, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_ipv4address = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->ipv6address != NULL)
          {
            g_free(this_object->ipv6address);
            this_object->ipv6address = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->ipv6address = g_byte_array_new();
          g_byte_array_append (this_object->ipv6address, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_ipv6address = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_p_address_type_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IPAddressType * this_object = I_P_ADDRESS_TYPE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IPAddressType", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_ipv4address == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ipv4address", T_I32, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->ipv4address, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ipv6address == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ipv6address", T_STRING, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, this_object->ipv6address ? ((GByteArray *) this_object->ipv6address)->data : NULL, this_object->ipv6address ? ((GByteArray *) this_object->ipv6address)->len : 0, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_p_address_type_set_property (GObject *object,
                               guint property_id,
                               const GValue *value,
                               GParamSpec *pspec)
{
  IPAddressType *self = I_P_ADDRESS_TYPE (object);

  switch (property_id)
  {
    case PROP_I_P_ADDRESS_TYPE_IPV4ADDRESS:
      self->ipv4address = g_value_get_int (value);
      self->__isset_ipv4address = TRUE;
      break;

    case PROP_I_P_ADDRESS_TYPE_IPV6ADDRESS:
      if (self->ipv6address != NULL)
        g_byte_array_unref (self->ipv6address);
      self->ipv6address = g_value_dup_boxed (value);
      self->__isset_ipv6address = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_p_address_type_get_property (GObject *object,
                               guint property_id,
                               GValue *value,
                               GParamSpec *pspec)
{
  IPAddressType *self = I_P_ADDRESS_TYPE (object);

  switch (property_id)
  {
    case PROP_I_P_ADDRESS_TYPE_IPV4ADDRESS:
      g_value_set_int (value, self->ipv4address);
      break;

    case PROP_I_P_ADDRESS_TYPE_IPV6ADDRESS:
      g_value_set_boxed (value, self->ipv6address);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_p_address_type_instance_init (IPAddressType * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->ipv4address = 0;
  object->__isset_ipv4address = FALSE;
  object->ipv6address = NULL;
  object->__isset_ipv6address = FALSE;
}

static void 
i_p_address_type_finalize (GObject *object)
{
  IPAddressType *tobject = I_P_ADDRESS_TYPE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ipv6address != NULL)
  {
    thrift_string_free(tobject->ipv6address);
    tobject->ipv6address = NULL;
  }
}

static void
i_p_address_type_class_init (IPAddressTypeClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_p_address_type_read;
  struct_class->write = i_p_address_type_write;

  gobject_class->finalize = i_p_address_type_finalize;
  gobject_class->get_property = i_p_address_type_get_property;
  gobject_class->set_property = i_p_address_type_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_P_ADDRESS_TYPE_IPV4ADDRESS,
     g_param_spec_int ("ipv4address",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_P_ADDRESS_TYPE_IPV6ADDRESS,
     g_param_spec_boxed ("ipv6address",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
i_p_address_type_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IPAddressTypeClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_p_address_type_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IPAddressType),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_p_address_type_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IPAddressTypeType",
                                   &type_info, 0);
  }

  return type;
}

enum _IPPrefixTypeProperties
{
  PROP_I_P_PREFIX_TYPE_0,
  PROP_I_P_PREFIX_TYPE_IPV4PREFIX,
  PROP_I_P_PREFIX_TYPE_IPV6PREFIX
};

/* reads a i_p_prefix_type object */
static gint32
i_p_prefix_type_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IPPrefixType * this_object = I_P_PREFIX_TYPE(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ipv4prefix), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_ipv4prefix = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ipv6prefix), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_ipv6prefix = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_p_prefix_type_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IPPrefixType * this_object = I_P_PREFIX_TYPE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IPPrefixType", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_ipv4prefix == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ipv4prefix", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ipv4prefix), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ipv6prefix == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ipv6prefix", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ipv6prefix), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_p_prefix_type_set_property (GObject *object,
                              guint property_id,
                              const GValue *value,
                              GParamSpec *pspec)
{
  IPPrefixType *self = I_P_PREFIX_TYPE (object);

  switch (property_id)
  {
    case PROP_I_P_PREFIX_TYPE_IPV4PREFIX:
      if (self->ipv4prefix != NULL)
        g_object_unref (self->ipv4prefix);
      self->ipv4prefix = g_value_dup_object (value);
      self->__isset_ipv4prefix = TRUE;
      break;

    case PROP_I_P_PREFIX_TYPE_IPV6PREFIX:
      if (self->ipv6prefix != NULL)
        g_object_unref (self->ipv6prefix);
      self->ipv6prefix = g_value_dup_object (value);
      self->__isset_ipv6prefix = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_p_prefix_type_get_property (GObject *object,
                              guint property_id,
                              GValue *value,
                              GParamSpec *pspec)
{
  IPPrefixType *self = I_P_PREFIX_TYPE (object);

  switch (property_id)
  {
    case PROP_I_P_PREFIX_TYPE_IPV4PREFIX:
      g_value_set_object (value, self->ipv4prefix);
      break;

    case PROP_I_P_PREFIX_TYPE_IPV6PREFIX:
      g_value_set_object (value, self->ipv6prefix);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_p_prefix_type_instance_init (IPPrefixType * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->ipv4prefix = g_object_new (TYPE_I_PV4_PREFIX_TYPE, NULL);
  object->__isset_ipv4prefix = FALSE;
  object->ipv6prefix = g_object_new (TYPE_I_PV6_PREFIX_TYPE, NULL);
  object->__isset_ipv6prefix = FALSE;
}

static void 
i_p_prefix_type_finalize (GObject *object)
{
  IPPrefixType *tobject = I_P_PREFIX_TYPE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ipv4prefix != NULL)
  {
    g_object_unref(tobject->ipv4prefix);
    tobject->ipv4prefix = NULL;
  }
  if (tobject->ipv6prefix != NULL)
  {
    g_object_unref(tobject->ipv6prefix);
    tobject->ipv6prefix = NULL;
  }
}

static void
i_p_prefix_type_class_init (IPPrefixTypeClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_p_prefix_type_read;
  struct_class->write = i_p_prefix_type_write;

  gobject_class->finalize = i_p_prefix_type_finalize;
  gobject_class->get_property = i_p_prefix_type_get_property;
  gobject_class->set_property = i_p_prefix_type_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_P_PREFIX_TYPE_IPV4PREFIX,
     g_param_spec_object ("ipv4prefix",
                         NULL,
                         NULL,
                         TYPE_I_PV4_PREFIX_TYPE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_P_PREFIX_TYPE_IPV6PREFIX,
     g_param_spec_object ("ipv6prefix",
                         NULL,
                         NULL,
                         TYPE_I_PV6_PREFIX_TYPE,
                         G_PARAM_READWRITE));
}

GType
i_p_prefix_type_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IPPrefixTypeClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_p_prefix_type_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IPPrefixType),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_p_prefix_type_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IPPrefixTypeType",
                                   &type_info, 0);
  }

  return type;
}

enum _PrefixSequenceTypeProperties
{
  PROP_PREFIX_SEQUENCE_TYPE_0,
  PROP_PREFIX_SEQUENCE_TYPE_TIMESTAMP,
  PROP_PREFIX_SEQUENCE_TYPE_TRANSACTIONID
};

/* reads a prefix_sequence_type object */
static gint32
prefix_sequence_type_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  PrefixSequenceType * this_object = PREFIX_SEQUENCE_TYPE(object);
  gboolean isset_timestamp = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->timestamp), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          isset_timestamp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_BYTE)
        {
          if ((ret = thrift_protocol_read_byte (protocol, &this_object->transactionid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_transactionid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_timestamp)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
prefix_sequence_type_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  PrefixSequenceType * this_object = PREFIX_SEQUENCE_TYPE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "PrefixSequenceType", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "timestamp", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->timestamp), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_transactionid == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "transactionid", T_BYTE, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_byte (protocol, this_object->transactionid, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
prefix_sequence_type_set_property (GObject *object,
                                   guint property_id,
                                   const GValue *value,
                                   GParamSpec *pspec)
{
  PrefixSequenceType *self = PREFIX_SEQUENCE_TYPE (object);

  switch (property_id)
  {
    case PROP_PREFIX_SEQUENCE_TYPE_TIMESTAMP:
      if (self->timestamp != NULL)
        g_object_unref (self->timestamp);
      self->timestamp = g_value_dup_object (value);
      break;

    case PROP_PREFIX_SEQUENCE_TYPE_TRANSACTIONID:
      self->transactionid = g_value_get_int (value);
      self->__isset_transactionid = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
prefix_sequence_type_get_property (GObject *object,
                                   guint property_id,
                                   GValue *value,
                                   GParamSpec *pspec)
{
  PrefixSequenceType *self = PREFIX_SEQUENCE_TYPE (object);

  switch (property_id)
  {
    case PROP_PREFIX_SEQUENCE_TYPE_TIMESTAMP:
      g_value_set_object (value, self->timestamp);
      break;

    case PROP_PREFIX_SEQUENCE_TYPE_TRANSACTIONID:
      g_value_set_int (value, self->transactionid);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
prefix_sequence_type_instance_init (PrefixSequenceType * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->timestamp = g_object_new (TYPE_I_E_E_E802_1_A_S_TIME_STAMP_TYPE, NULL);
  object->transactionid = 0;
  object->__isset_transactionid = FALSE;
}

static void 
prefix_sequence_type_finalize (GObject *object)
{
  PrefixSequenceType *tobject = PREFIX_SEQUENCE_TYPE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->timestamp != NULL)
  {
    g_object_unref(tobject->timestamp);
    tobject->timestamp = NULL;
  }
}

static void
prefix_sequence_type_class_init (PrefixSequenceTypeClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = prefix_sequence_type_read;
  struct_class->write = prefix_sequence_type_write;

  gobject_class->finalize = prefix_sequence_type_finalize;
  gobject_class->get_property = prefix_sequence_type_get_property;
  gobject_class->set_property = prefix_sequence_type_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_PREFIX_SEQUENCE_TYPE_TIMESTAMP,
     g_param_spec_object ("timestamp",
                         NULL,
                         NULL,
                         TYPE_I_E_E_E802_1_A_S_TIME_STAMP_TYPE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PREFIX_SEQUENCE_TYPE_TRANSACTIONID,
     g_param_spec_int ("transactionid",
                       NULL,
                       NULL,
                       G_MININT8,
                       G_MAXINT8,
                       0,
                       G_PARAM_READWRITE));
}

GType
prefix_sequence_type_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (PrefixSequenceTypeClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) prefix_sequence_type_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (PrefixSequenceType),
      0, /* n_preallocs */
      (GInstanceInitFunc) prefix_sequence_type_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "PrefixSequenceTypeType",
                                   &type_info, 0);
  }

  return type;
}

/* constants */
GHashTable *
empty_set_of_nodeids_constant (void)
{
  static GHashTable *constant = NULL;
  if (constant == NULL)
  {

    constant = g_hash_table_new_full (g_int64_hash, g_int64_equal, g_free, NULL);
  }
  return constant;
}


